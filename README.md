# GitTrainingRepository
## For git training

### **Config:**
git config --global user.name "username"

git config --global user.email "email"

git config --global color.ui true

### **Create project:**
mkdir project_name

cd project_name

git init

### **Commands:**
**git add** file1 file2 - *подготовить (добавить в отслеживаемую зону) файлы file1 и file2 к коммиту.*

**git add** . - *подготовить все файлы в текущей папке к коммиту.*

**git add** *.java - *подготовить все файлы в текущей папке с расширением java к коммиту.*

**git add** someDir/*.java - *подготовить все файлы в папке someDir с расширением java к коммиту.*

**git add** someDir/ - *подготовить все файлы в папке someDir к коммиту.*

**git add** "*.java" - *подготовить все файлы в проекте с расширением java к коммиту.*

**git commit -m "Message"** - *сделать коммит (зафиксировать, сделать снимок) с сообщением message.*

**git status** - *узнать текущий статус репозитория.*

**git diff** - *показывает разницу между текущим неотслеживаемым состоянием репозитория и последним снимком репозитория.*

**git diff --staged** - *показывает разницу между текущим отслеживаемым состоянием репозитория и последним снимком репозитория.*

**git diff COMMIT_ID** - *показывает разницу между текущим состоянием репозитория и указанным снимком репозитория.*

**git reset --soft** - *возвращает проект к указанному коммиту, при этом переводит все коммиты после указанного в отслеживаемую зону.*

**git reset --mixed** - *возвращает проект к указанному коммиту, при этом переводит все коммиты после указанного в неотслеживаемую зону.*

**git reset --hard** - *возвращает проект к указанному коммиту, при этом полностью удаляет все коммиты после указанного.*

*команда **git reset** используется с указателем HEAD (пример: git reset --hard HEAD^^ или git reset --hard HEAD~2) или с ID конкретного коммита; по умолчанию применяется параметр --mixed.*

**git checkout COMMIT_ID/HEAD^^/HEAD~2** - *перемещает между коммитами, никакие коммиты не удаляются, в любой момент можно вернуться в актуальную версию.*

**git checkout COMMIT_ID -- file_name** - *перемещает между версиями файлов, возвращает файл file_name к версии в указанном коммите.*

**git checkout -- .** - *возвращает все файлы в репозитории к версии, которая была у них в последнем коммите (работает только для неотслеживаемых изменений).*

**git commit -a -m "Message"** - *то же самое, что последовательное выполнение **git add .** и **git commit -m "Message"**.*

**git commit --amend -m "New commit message"** - *дополняет последний коммит, добавляя в него "свежие" изменения, меняет сообщение последнего коммита (новый коммит не создается).*

**git clean -n** - *работает с untracked файлами, покажет какие файлы будут удалены.*

**git clean -f** - *совершает удаление untracked файлов.*

**git remote -v** - *просмотр списка существующих удаленных репозиториев.*

**git remote add REPOSITORY_NAME REPOSITORY_ADDRESS** - *добавить новый удаленный репозиторий, который находится по указанному адресу, при этом, на нашем компьютере к удаленному репозиторию мы будем обращаться по его названию.*

**git remote remove REPOSITORY_NAME** - *удалить репозиторий с указанным названием.*

**git push REMOTE_REPOSITORY_NAME BRANCH_NAME** - *команда для отправки локального репозитория на удаленный: отправляем на удаленный репозиторий с именем REMOTE_REPOSITORY_NAME нашу ветку BRANCH_NAME.*

**git pull REMOTE_REPOSITORY_NAME BRANCH_NAME** - *командля для получения обновлений с удаленного репозитория: скачиваем новые коммиты.*

**git clone REMOTE_REPOSITORY_NAME** - *полностью скачивает удаленный репозиторий на наш компьютер.*

**git branch** - *команда для просмотра на какой ветке мы сейчас находимся.*

**git branch BRANCH_NAME** - *команда для создания новой ветки.*

**git branch -d BRANCH_NAME** - *команда для удаления ветки.*

**git checkout BRANCH_NAME** - *команда для переключения между ветками.*

**git branch -r** - *команда для просмотра состояния веток в наших удаленных репозиториях.*

**git merge BRANCH_NAME** - *сливает одну ветку с другой: ту, в которой находимся с BRANCH_NAME.*

**git rebase BRANCH_NAME** - *альтернатива **merge**, сливает ветки без коммита слияния. При конфликте слияния решение такое же, как и при **merge**. После решения конфликта вручную, можно продолжить **rebase** с помощью команды **git rebase --continue** или же отказаться от слияния с помощью команды **git rebase --abort**.*

**git rebase -i HEAD^/HEAD~3** - *работает с коммитами, которые идут **после указанного (HEAD^/HEAD~2/etc)**. Работает на одной ветке, перемещает некоторые коммиты из текущей ветки во временную зону и потом применяет эти коммиты к текущей ветке. Изменяя инструкцию применения коммитов, можно сделать множество манипуляций:*
- Поменять коммиты местами
- Поменять название коммита/коммитов
- Объединить два коммита в один
- Добавить изменения в существующий коммит
- Разделить коммит на несколько коммитов

**git cherry-pick COMMIT_ID** - *используется тогда, когда нам надо взять один или несколько коммитов из другой ветки в нашу ветку (У взятого коммита будет другой хэш, отличный от хэша в оригинальной ветке (то есть формально это новый коммит).*

**git cherry-pick --edit COMMIT_ID** - *используется, когда надо перенести коммит из другой ветки, но при этом хотим поменять сообщение коммита.*

**git cherry-pick --no-commit COMMIT_ID1 COMMIT_ID2** - *используется, когда надо перенести изменения из коммита другой ветки, но при этом не хотим делать коммит в нашей ветке, изменения просто попадут в отслеживаемую зону. Другой сценарий - слияние двух коммитов из другой ветки в один коммит.*

**git cherry-pick -x COMMIT_ID** - *указывает в сообщении коммита хэш того коммита, из которого мы сделали cherry-pick.*

**git cherry-pick --signoff COMMIT_ID** - *указывает в сообщении коммита имя того пользователя, кто совершил cherry-pick.*
